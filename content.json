[{"title":"Note","date":"2022-08-31T18:30:13.000Z","path":"2022/09/01/Commandments/","text":"不乱于心，不困于情，不畏将来，不念过往，如此，安好。 好好学习，安排计划 找啥小哥哥，抢肉吃吗？ 煲剧打游戏哪有学习好玩？ 吐槽什么代码，又没人家厉害 过教资 过雅托 还有六级 不要和人家哔哔，关你屁事，关你屁事，关你屁事 ==========================================","tags":[{"name":"casually","slug":"casually","permalink":"http://yoursite.com/tags/casually/"}]},{"title":"“Emo-20220701”","date":"2022-07-01T15:29:45.000Z","path":"2022/07/01/daily/“Emo-20220701”/","text":"其实明明，现在遇到的一切困难，都是意料之中的。 做决定的时候，就做好准备了，不是么？ 研究生巅峰啦，有人管有人疼的！","tags":[{"name":"casually","slug":"casually","permalink":"http://yoursite.com/tags/casually/"}]},{"title":"随笔20220629","date":"2022-06-29T15:42:39.000Z","path":"2022/06/29/daily/随笔20220629/","text":"突然有点期待30岁，会不会有什么不一样的东西。 感觉科研越来越顺手了，但还是好菜啊哈哈哈 不知道以后会怎么样，充满期待 真的好想成为自己心中的合格的样子啊 还有一丝丝想要迷信算命，但是又不会影响我的抉择","tags":[{"name":"casually","slug":"casually","permalink":"http://yoursite.com/tags/casually/"}]},{"title":"Record and Say ‘GOOD BYE’","date":"2022-06-22T17:54:21.000Z","path":"2022/06/23/daily/Record-and-Say-‘GOOD-BYE’/","text":"It’s the last time I retrospect the past years. Just after I have graduated, I have the chance to apply to ITP and I could get it(if I wanted). But I miss the chance. Maybe, I will never go there. Before 5 years ago, I wascowardice and cared about many things unworthy. Perhaps, it was my destiny to suffer such bad things. Can I blame others make me a loser ? But I can not. I know, everthing is my choice. I can not accept my failure about those years. I am the person who can not accept the gaps of my life. I still want to say, why is me ? what I did wrong ? who will pay my lost years——the most preciour years for a physicsor. When I face to the options, I know others are all easy and operable. But I chose the most hardness one, and I must overcome every difficulties only by myself. After I know that not only me give up many things, I could feel relived with those abandoned options. But, I do not know when I can let things go about my years. May be I become a doctor or a junior elite or I can join in ITP ? Anyway, I can not control the past, and I only can look forward. Thus, I could never addicted to the past. I will and must try my best for the future.","tags":[{"name":"emo","slug":"emo","permalink":"http://yoursite.com/tags/emo/"}]},{"title":"一只小仙女","date":"2022-06-03T06:12:06.000Z","path":"2022/06/03/daily/一只小仙女/","text":"Hello！这里是一只小仙女！ 终于复活了我的blog 鬼知道什么时候会写点什么 以后就是个科研狗啦！o(￣▽￣)ブ","tags":[{"name":"casually","slug":"casually","permalink":"http://yoursite.com/tags/casually/"}]},{"title":"Test","date":"2019-06-12T07:25:45.000Z","path":"2019/06/12/Test/","text":"这是一个测试，这只是一个测试，什么都没有。","tags":[{"name":"Hello","slug":"Hello","permalink":"http://yoursite.com/tags/Hello/"}]},{"title":"基础版DAO设计","date":"2019-06-01T07:39:32.000Z","path":"2019/06/01/computer/基础版DAO设计/","text":"很久很久以前 总有大佬让我帮他DAO debug，于是终于有了此篇文章. 基础版DAO设计DAO设计思路1、建立VO类2、建立数据连接ThreadLocal类设置局部变量conn确保线程安全 getConnection()方法和rebuildConnection方法() 3、数据层操作定义DAO操作公共标准，包括增、减、查、分页、统计等操作 定义特定VO类操作标准 实现类 4、业务层操作Service操作标准，包括增、减、查、分页、统计等方法 建立工厂类获取DAO类实例化对象 实现类 5、测试类代理类处理业务层操作(判断事务控制) 工厂类获取业务层代理类实例化对象(绑定业务层实例化对象) 测试操作(客户端调用) 准备工作创建一个数据表1234567891011DROP TABLE member PURGE ;CREATE TABLE member( mid VARCHAR2(20), name VARCHAR2(20), age NUMBER(3), email VARCHAR2(50), sex VARCHAR2(10), birthday DATE, note CLOB, CONSTRAINT pk_mid PRIMARY KEY(mid)); 实现VO类123456789101112131415161718192021222324252627282930313233package vo;import java.sql.Date;public class Member &#123; private String mid ; private String name ; private Integer age ; private String email ; private String sex ; private Date birthday ; private String node ; public Member() &#123;&#125; @Override public String toString() &#123; return &quot;Member&#123;&quot; + &quot;mid=&apos;&quot; + mid + &apos;\\&apos;&apos; + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &quot;, email=&apos;&quot; + email + &apos;\\&apos;&apos; + &quot;, sex=&apos;&quot; + sex + &apos;\\&apos;&apos; + &quot;, birthday=&quot; + birthday + &quot;, node=&apos;&quot; + node + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; public Member(String mid, String name, Integer age, String email, String sex, Date birthday, String node) &#123; this.mid = mid; this.name = name; this.age = age; this.email = email; this.sex = sex; this.birthday = birthday; this.node = node; &#125; //setter、getter略 创建数据库连接类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package util.dbc; import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException; public class DatabaseConnection &#123; private static final String DBDRIVER = &quot;oracle.jdbc.driver.OracleDriver&quot; ; private static final String DBULR = &quot;jdbc:oracle:thin:@localhost:1521:ORCL&quot; ; private static final String USER = &quot;scott&quot; ; private static final String PASSWORD = &quot;tiger&quot; ; private static final ThreadLocal&lt;Connection&gt; CONNECTION_THREAD_LOCAL = new ThreadLocal&lt;&gt;() ; /** * 通过构造方法进行实例化，表示需要获取一个数据库连接 * 数据库的连接通过本类的实例封装，调用此方法连接数据库 */ private DatabaseConnection()&#123;&#125; public static void rebuildConnection()&#123; try&#123; Class.forName(DBDRIVER) ; //驱动加载 Connection conn = DriverManager.getConnection(DBULR,USER,PASSWORD) ; CONNECTION_THREAD_LOCAL.set(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 返回一个JDBC连接对象，如果连接失败返回null * @return Connection接口实例 */ public static Connection getConnection()&#123; Connection conn = CONNECTION_THREAD_LOCAL.get() ; if(conn == null)&#123; //如果conn为空，调用rebuildConnection实现数据库的连接 rebuildConnection(); conn = CONNECTION_THREAD_LOCAL.get() ; &#125; return conn ; &#125; public static void close() throws Exception &#123; Connection conn = CONNECTION_THREAD_LOCAL.get() ; if(conn != null)&#123; try &#123; conn.close(); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; CONNECTION_THREAD_LOCAL.remove(); &#125; &#125;&#125; DAO操作定义公共DAO操作标准1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package dao; import java.sql.SQLException;import java.util.List;import java.util.Set;/** * DAO公共接口 * @param &lt;K&gt; 主键类型 * @param &lt;V&gt; VO类型 */public interface IBaseDAO&lt;K,V&gt; &#123; /** * 实现数据增加操作 * * @param vo 保存要增加的数据的信息类，该类属性确定已经合法 * @return 数据保存成功return true，否则 return false * @throws SQLException 数据库执行异常 */ public boolean doCreate(V vo) throws SQLException; /** * 实现数据修改操作，根据id进行修改 * * @param vo 保存要修改数据的完整数据 * @return 修改成功返回 true ，否则返回false * @throws SQLException 数据库执行异常 */ public boolean doEdit(V vo) throws SQLException; /** * 数据的删除操作，可以删除指定范围中的数据信息 * * @param ids 要删除的数据id，不允许重复 * @return 删除成功返回true ，否则返回false * @throws SQLException 数据库执行异常 */ public boolean doRemove(Set&lt;K&gt; ids) throws SQLException; /** * 根据id查询数据 * * @param id 要查询的数据id * @return 数据存在返回数据对象，否则返回null * @throws SQLException 数据库执行异常 */ public V findById(K id) throws SQLException; /** * 查询所有数据 * * @return 返回所有数据对象的集合，如果没有数据则集合长度为0 * @throws SQLException 数据库执行异常 */ public List&lt;V&gt; findAll() throws SQLException; /** * 全部分页信息的查询 * * @param currentPage 当前所在页 * @param lineSize 每页数据行数 * @return 返回该页数据对象的集合，如果没有数据则返回集合长度为0 * @throws SQLException 数据库执行异常 */ public List&lt;V&gt; findSplit(Integer currentPage, Integer lineSize) throws SQLException; /** * 根据关键字分页查询 * * @param currentPage 当前所在页 * @param lineSize 每页显示的数据行数 * @param column 模糊查询的列 * @param keyword 模糊查询的关键字 * @return 如果存在以集合形式返回数据对象，如果数据不存在返回集合长度为0 * @throws SQLException 数据库执行异常 */ public List&lt;V&gt; findSplit(Integer currentPage, Integer lineSize, String column, String keyword) throws SQLException; /** * 统计全部数据 * * @return COUNT()函数的返回结果 * @throws SQLException 数据库执行异常 */ public Long getAllCount() throws SQLException; /** * 统计搜索数据数量 * * @param column 模糊查询列 * @param keyword 模糊查询关键字 * @return COUNT()函数返回的结果 * @throws SQLException 数据库执行异常 */ public Long getAllCount(String column, String keyword) throws SQLException;&#125; 定义IMemberDAO操作标准1234567891011121314package dao; import vo.Member; import java.sql.SQLException;import java.util.List;import java.util.Set; public interface IMemberDAO extends IBaseDAO&lt;String ,Member&gt;&#123; //继承父接口全部方法 /** * 根据email查询数据 * @param email 要查询数据的email * @return 数据存在返回数据对象，否则返回null * @throws SQLException 数据库执行异常 */ public Member findByEmail(String email)throws SQLException ; //member表操作&#125; DAO抽象类进行公共处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package util.abs; import util.dbc.DatabaseConnection; import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Iterator;import java.util.Set; public abstract class AbstractDAO &#123; protected PreparedStatement pstmt ; protected Connection conn ; public AbstractDAO()&#123; this.conn = DatabaseConnection.getConnection(); &#125; protected Long handleGetAllCount(String tableName) throws SQLException &#123; String sql = &quot;SELECT COUNT(*) FROM &quot; + tableName ; this.pstmt = this.conn.prepareStatement(sql) ; ResultSet rs = this.pstmt.executeQuery() ; if(rs.next())&#123; return rs.getLong(1) ; &#125; return 0L ; &#125; protected Long hangdleGetAllCount(String tableName,String column, String keyword) throws SQLException &#123; String sql = &quot;SELECT COUNT(*) FROM &quot; + tableName + &quot; WHERE &quot; + column + &quot; LIKE ? &quot; ; this.pstmt = this.conn.prepareStatement(sql) ; this.pstmt.setString(1,&quot;%&quot; + keyword + &quot;%&quot;); ResultSet rs = this.pstmt.executeQuery() ; if(rs.next())&#123; return rs.getLong(1) ; &#125; return 0L ; &#125; protected boolean handleRemoveByString(String tableName, String idColumn, Set&lt;String&gt; ids) throws SQLException&#123; StringBuffer sql = new StringBuffer(30) ; sql.append(&quot;DELETE FROM &quot;).append(tableName).append(&quot; WHERE &quot;).append(idColumn).append(&quot; IN (&quot; ); ids.forEach((id)-&gt;&#123; sql.append(&quot;?,&quot;) ; &#125;); sql.delete(sql.length()-1,sql.length()).append(&quot;)&quot;) ; this.pstmt = this.conn.prepareStatement(sql.toString()) ; Iterator&lt;String&gt; iter = ids.iterator() ; int foot = 1 ; while(iter.hasNext())&#123; this.pstmt.setString(foot++,iter.next()); &#125; return this.pstmt.executeUpdate() == ids.size() ; &#125; protected boolean handleRemoveByLong(String tableName, String idColumn, Set&lt;Long&gt; ids) throws SQLException&#123; StringBuffer sql = new StringBuffer(30) ; sql.append(&quot;DELETE FROM &quot;).append(tableName).append(&quot; WHERE &quot;).append(idColumn).append(&quot; IN (&quot; ); ids.forEach((id)-&gt;&#123; sql.append(&quot;?,&quot;) ; &#125;); sql.delete(sql.length()-1,sql.length()).append(&quot;)&quot;) ; this.pstmt = this.conn.prepareStatement(sql.toString()) ; Iterator&lt;Long&gt; iter = ids.iterator() ; int foot = 1 ; while(iter.hasNext())&#123; this.pstmt.setLong(foot++, iter.next()); &#125; return this.pstmt.executeUpdate() == ids.size() ; &#125;&#125; IMemberDAO实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package dao.impl; import util.abs.AbstractDAO;import util.dbc.DatabaseConnection;import vo.Member; import java.sql.Connection;import java.sql.Date;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set; public class MemberDAOImpl extends AbstractDAO implements dao.IMemberDAO &#123; public MemberDAOImpl() &#123; DatabaseConnection.getConnection(); &#125; @Override public boolean doCreate(Member vo) throws SQLException &#123; String sql = &quot;INSERT INTO member(mid,name,age,email,sex,birthday,note) VALUES (?,?,?,?,?,?,?)&quot; ; super.pstmt = super.conn.prepareStatement(sql) ; super.pstmt.setString(1,vo.getMid()); super.pstmt.setString(2,vo.getName()); super.pstmt.setInt(3,vo.getAge()); super.pstmt.setString(4,vo.getEmail()); super.pstmt.setString(5,vo.getSex()); super.pstmt.setDate(6,vo.getBirthday()); super.pstmt.setString(7,vo.getNode()); return super.pstmt.executeUpdate() &gt; 0; &#125; @Override public boolean doEdit(Member vo) throws SQLException &#123; String sql = &quot;UPDATE member SET name=?,age=?,email=?,sex=?,birthday=?,note=? WHERE mid=?&quot; ; super.pstmt = super.conn.prepareStatement(sql) ; super.pstmt.setString(1,vo.getName()); super.pstmt.setInt(2,vo.getAge()); super.pstmt.setString(3,vo.getEmail()); super.pstmt.setString(4,vo.getSex()); super.pstmt.setDate(5,vo.getBirthday()); super.pstmt.setString(6,vo.getNode()); super.pstmt.setString(7,vo.getMid()); return super.pstmt.executeUpdate() &gt; 0; &#125; @Override public boolean doRemove(Set&lt;String&gt; ids) throws SQLException &#123; return super.handleRemoveByString(&quot;member&quot;,&quot;mid&quot;,ids) ; &#125; @Override public Member findById(String id) throws SQLException &#123; Member vo = null ; String sql = &quot;SELECT mid,name,age,email,sex,birthday,note FROM member WHERE mid=?&quot; ; super.pstmt = super.conn.prepareStatement(sql) ; super.pstmt.setString(1,id); ResultSet rs = super.pstmt.executeQuery() ; if(rs.next())&#123; vo = new Member() ; vo.setMid(rs.getString(1)); vo.setName(rs.getString(2)); vo.setAge(rs.getInt(3)); vo.setSex(rs.getString(4)); vo.setEmail(rs.getString(5)); vo.setBirthday(rs.getDate(6)) ; vo.setNode(rs.getString(7)) ; &#125; return vo ; &#125; @Override public Member findByEmail(String email) throws SQLException &#123; Member vo = null ; String sql = &quot;SELECT mid,name,age,email,sex,birthday,note FROM member WHERE email=?&quot; ; super.pstmt = super.conn.prepareStatement(sql) ; super.pstmt.setString(1,email); ResultSet rs = super.pstmt.executeQuery() ; if(rs.next())&#123; vo = new Member() ; vo.setMid(rs.getString(1)); vo.setName(rs.getString(2)); vo.setAge(rs.getInt(3)); vo.setSex(rs.getString(4)); vo.setEmail(rs.getString(5)); vo.setBirthday(rs.getDate(6)) ; vo.setNode(rs.getString(7)) ; &#125; return vo ; &#125; @Override public List&lt;Member&gt; findAll() throws SQLException &#123; List&lt;Member&gt; all = new ArrayList() ; String sql = &quot;SELECT mid,name,age,email,sex,birthday,note FROM member&quot; ; super.pstmt = super.conn.prepareStatement(sql) ; ResultSet rs = super.pstmt.executeQuery() ; while(rs.next())&#123; Member vo = new Member() ; vo.setMid(rs.getString(1)); vo.setName(rs.getString(2)); vo.setAge(rs.getInt(3)); vo.setSex(rs.getString(4)); vo.setEmail(rs.getString(5)); vo.setBirthday(rs.getDate(6)) ; vo.setNode(rs.getString(7)) ; all.add(vo) ; &#125; return all ; &#125; @Override public List&lt;Member&gt; findSplit(Integer currentPage, Integer lineSize) throws SQLException &#123; List&lt;Member&gt; all = new ArrayList&lt;&gt;() ; String sql = &quot;SELECT * FROM ( &quot; + &quot; SELECT mid,name,age,email,sex,birthday,note,ROWNUM rn FROM member &quot; + &quot; WHERE ROWNUM &lt;= ? )temp WHERE temp.rn &gt; ? &quot;; super.pstmt = super.conn.prepareStatement(sql) ; super.pstmt.setInt(1,currentPage * lineSize); super.pstmt.setInt(2,(currentPage - 1) * lineSize); ResultSet rs = super.pstmt.executeQuery(); while(rs.next())&#123; Member vo = new Member() ; vo.setMid(rs.getString(1)); vo.setName(rs.getString(2)); vo.setAge(rs.getInt(3)); vo.setSex(rs.getString(4)); vo.setEmail(rs.getString(5)); vo.setBirthday(rs.getDate(6)) ; vo.setNode(rs.getString(7)) ; all.add(vo) ; &#125; return all ; &#125; @Override public List&lt;Member&gt; findSplit(Integer currentPage, Integer lineSize, String column, String keyword) throws SQLException &#123; List&lt;Member&gt; all = new ArrayList&lt;&gt;() ; String sql = &quot;SELECT * FROM ( &quot; + &quot; SELECT mid,name,age,email,sex,birthday,note,ROWNUM rn FROM member &quot; + &quot; WHERE &quot; + column + &quot; LIKE ? AND ROWNUM &lt;= ? ) temp WHERE temp.rn &gt; ? &quot;; super.pstmt = super.conn.prepareStatement(sql) ; super.pstmt.setString(1,&quot;%&quot; + keyword + &quot;%&quot;); super.pstmt.setInt(2,currentPage * lineSize); super.pstmt.setInt(3,(currentPage - 1) * lineSize); ResultSet rs = super.pstmt.executeQuery() ; while(rs.next())&#123; Member vo = new Member() ; vo.setMid(rs.getString(1)); vo.setName(rs.getString(2)); vo.setAge(rs.getInt(3)); vo.setSex(rs.getString(4)); vo.setEmail(rs.getString(5)); vo.setBirthday(rs.getDate(6)) ; vo.setNode(rs.getString(7)) ; all.add(vo) ; &#125; return all ; &#125; @Override public Long getAllCount() throws SQLException &#123; return super.handleGetAllCount(&quot;member&quot;) ; &#125; @Override public Long getAllCount(String column, String keyword) throws SQLException &#123; return super.hangdleGetAllCount(&quot;member&quot;,column,keyword) ; &#125;&#125; 工厂类获取实例化对象12345678910111213141516171819202122232425package util.factory;import util.proxy.ServiceProxy;import java.util.ResourceBundle;public class ObjectFactory &#123; /** *创建配置文件 *resource.dao(member.dao=dao.imple.IMemberDAOImpl) **/ private static final ResourceBundle DAO_RESOURCE = ResourceBundle.getBundle(&quot;resource.dao&quot;) ; public static&lt;T&gt; T getDAOInstance(String key,Class&lt;T&gt;...clazz)&#123; String className = null ; try&#123; className = DAO_RESOURCE.getString(key) ; &#125;catch(Exception e)&#123; if(className == null || &quot;&quot;.equals(className))&#123; return null ; &#125; &#125; try&#123; return (T) Class.forName(className).getDeclaredConstructor().newInstance() ; &#125;catch(Exception e)&#123; return null ; &#125; &#125;&#125; 业务层实现定义业务层操作标准1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package service;import vo.Member;import java.sql.SQLException;import java.util.List;import java.util.Map;public interface IMemberService &#123; /** * 实现数据的增加操作 * 1，检查输入数据是否正确 * 2，调用IMemberDAO.findDyId()方法判断当前增加id是否存在 * 3，调用IMemberDAO.findByEmail()方法判断当前增加的Email是否存在 * 4，没有问题则调用ImemberDAO.doCreate()方法实现数据的增加 * @param vo 要增加的数据对象 * @return 增加成功返回true，否则返回false */ public boolean add(Member vo) throws SQLException; /** * 实现数据的修改操作 * 该操作调用IMemberDAO.doEdit()方法进行全部的数据更新，根据id完成 * @param vo 要更新的数据对象，一定要包含id * @return 修改成功返回true，否则返回false */ public boolean edit(Member vo) throws SQLException; /** * 数据的删除操作 * 调用IMemberDAO.doRemove()方法 * @param ids 所有要删除的数据的id的集合 * @return 全部删除成功返回true，否则返回false */ public boolean removeById(String ...ids) throws SQLException; /** * 根据id查询数据 * 调用IMemberDAO.findById（)方法 * @param id 要查询的id * @return 数据存在返回vo对象，否则返回null */ public Member get(String id) throws SQLException; /** * 查询全部数据 * 调用IMemberDAO.findAll()方法 * @return 返回数据对象的集合，如果数据不存在则返回集合长度为0 */ public List&lt;Member&gt; list() throws SQLException; /** * 数据的分页查询和数据统计 * 如果column和keyword为空，则进行全部数据查询以及统计 * 如果column和keyword不为空，则进行查询数据的分页显示以及统计 * @param currentPage 当前所在页 * @param lineSize 每页行数 * @param column 查询的列 * @param keyword 关键字 * @return 返回两种数据结果 * key = allResult，value = List 数据的查询结果 * key = allCount， value = Long 统计结果 */ public Map&lt;String,Object&gt; split(Integer currentPage,Integer lineSize,String column,String keyword) throws SQLException;&#125; 业务层实现类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package service.impl; import dao.IMemberDAO;import service.IMemberService;import util.dbc.DatabaseConnection;import util.factory.ObjectFactory;import vo.Member;import java.sql.SQLException;import java.util.*; public class MemberServiceImpl implements IMemberService &#123; @Override public boolean add(Member vo) throws SQLException &#123; //判断数据是否正确 if (vo.getAge() &gt; 150 || vo.getAge() &lt; 0) &#123; return false; &#125; if (!(vo.getSex().equalsIgnoreCase(&quot;F&quot;) || vo.getSex().equalsIgnoreCase(&quot;M&quot;))) &#123; return false; &#125; IMemberDAO memberDAO = ObjectFactory.getDAOInstance(&quot;member.dao&quot;); if (memberDAO.findById(vo.getMid()) == null) &#123; //mid和email不可重复 if (memberDAO.findByEmail(vo.getEmail()) == null) &#123; return memberDAO.doCreate(vo); &#125; &#125; return false; &#125; @Override public boolean edit(Member vo) throws SQLException &#123; if (vo.getAge() &gt; 150 || vo.getAge() &lt; 0) &#123; return false; &#125; if (!(vo.getSex().equalsIgnoreCase(&quot;F&quot;) || vo.getSex().equalsIgnoreCase(&quot;M&quot;))) &#123; return false; &#125; IMemberDAO memberDAO = ObjectFactory.getDAOInstance(&quot;member.dao&quot;, IMemberDAO.class); return memberDAO.doEdit(vo); &#125; @Override public boolean removeById(String... ids) throws SQLException &#123; if (ids.length == 0) &#123; return false; &#125; Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(Arrays.asList(ids)); DatabaseConnection.getConnection().setAutoCommit(false); IMemberDAO memberDAO = ObjectFactory.getDAOInstance(&quot;member.dao&quot;,IMemberDAO.class); return memberDAO.doRemove(set); &#125; @Override public Member get(String id) throws SQLException &#123; IMemberDAO memberDAO = ObjectFactory.getDAOInstance(&quot;member.dao&quot;,IMemberDAO.class); return memberDAO.findById(id); &#125; @Override public List&lt;Member&gt; list() throws SQLException &#123; IMemberDAO memberDAO = ObjectFactory.getDAOInstance(&quot;member.dao&quot;, IMemberDAO.class); return memberDAO.findAll(); &#125; @Override public Map&lt;String, Object&gt; split(Integer currentPage, Integer lineSize, String column, String keyword) throws SQLException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); IMemberDAO memberDAO = ObjectFactory.getDAOInstance(&quot;member.dao&quot;, IMemberDAO.class); if (column == null || &quot;&quot;.equalsIgnoreCase(column) || keyword == null || &quot;&quot;.equalsIgnoreCase(keyword)) &#123; map.put(&quot;allMembers&quot;, memberDAO.findSplit(currentPage, lineSize)); map.put(&quot;allRecorders&quot;, memberDAO.getAllCount()); &#125; else &#123; map.put(&quot;allMembers&quot;, memberDAO.findSplit(currentPage, lineSize, column, keyword)); map.put(&quot;allRecorders&quot;, memberDAO.getAllCount(column, keyword)); &#125; return map; &#125;&#125; 代理类和工厂类获取业务层实例化对象动态代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package util.proxy; import util.dbc.DatabaseConnection; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Iterator;import java.util.List; public class ServiceProxy implements InvocationHandler &#123; private static final List&lt;String&gt; TRANSACTION_METHOD_HEAD = List.of(&quot;add&quot;,&quot;create&quot;,&quot;edit&quot;,&quot;update&quot;,&quot;remove&quot;,&quot;delete&quot;) ; //需要事务控制的方法名 private Object target ; public Object bind(Object target)&#123; //绑定真实操作类 this.target = target ; return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this) ; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null ; boolean transactionFlag = this.openTransaction(method.getName()) ; if(transactionFlag)&#123; DatabaseConnection.getConnection().setAutoCommit(false); &#125; try&#123; result = method.invoke(this.target,args) ; if(transactionFlag)&#123; DatabaseConnection.getConnection().commit(); &#125; &#125;catch(Exception e)&#123; if(transactionFlag)&#123; DatabaseConnection.getConnection().rollback(); &#125; throw e ; &#125;finally&#123; DatabaseConnection.close(); &#125; return result ; &#125; /** *判断是否需要事务控制 **/ private boolean openTransaction(String methodName) &#123; Iterator&lt;String&gt; iter = TRANSACTION_METHOD_HEAD.iterator() ; while(iter.hasNext())&#123; if(methodName.startsWith(iter.next()))&#123; return true ; &#125; &#125; return false ; &#125;&#125; 工厂类获取业务层实例化对象创建配置文件resource.service(member.service=service.imple.IMemberServiceImpl) 在工厂类中增加如下内容1234567891011121314151617private static final ResourceBundle SERVICE_RESOURCE = ResourceBundle.getBundle(&quot;resource.service&quot;) ;public static &lt;T&gt; T getServiceInstance(String key,Class&lt;T&gt;...clazz)&#123; String className = null ; try&#123; className = SERVICE_RESOURCE.getString(key) ; &#125;catch(Exception e)&#123; if(className == null || &quot;&quot;.equals(className))&#123; return null &#125; &#125; try&#123; return (T) new ServiceProxy().bind( Class.forName(className).getDeclaredConstructor().newInstance()) ; &#125;catch(Exception e)&#123; return null ; &#125;&#125; 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package test; import junit.framework.TestCase;import org.junit.Test;import service.IMemberService;import util.factory.ObjectFactory;import vo.Member; import java.sql.Date;import java.sql.SQLException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.List;import java.util.Map; public class MemberServiceImplTest &#123; @Test public void add() throws SQLException &#123; Member member = new Member() ; member.setMid(&quot;0000&quot;) ; member.setName(&quot;sblj&quot;) ; member.setAge(18) ; member.setEmail(&quot;sblj@git.cn&quot;) ; member.setSex(&quot;F&quot;) ; try &#123; member.setBirthday(new Date(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2000-01-01&quot;).getTime())) ; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; member.setNode(&quot;是个大美女&quot;); IMemberService memberService = ObjectFactory.getServiceInstance(&quot;member.service&quot;) ; TestCase.assertTrue(memberService.add(member)); &#125; @Test public void edit() throws SQLException &#123; Member member = new Member() ; member.setMid(&quot;0000&quot;) ; member.setName(&quot;sblj&quot;) ; member.setAge(18) ; member.setEmail(&quot;这里不能重复@git.cn&quot;) ; member.setSex(&quot;F&quot;) ; try &#123; member.setBirthday(new Date(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2000-01-01&quot;).getTime())) ; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; member.setNode(&quot;还是个大美女&quot;); IMemberService memberService = ObjectFactory.getServiceInstance(&quot;member.service&quot;) ; TestCase.assertTrue(memberService.edit(member)); &#125; @Test public void removeById() throws SQLException &#123; IMemberService memberService = ObjectFactory.getServiceInstance(&quot;member.service&quot;) ; TestCase.assertTrue(memberService.removeById(&quot;0000&quot;)); &#125; //删除后再add()一次，不然没有数据哦 @Test public void get() throws SQLException &#123; IMemberService memberService = ObjectFactory.getServiceInstance(&quot;member.service&quot;) ; Member member = memberService.get(&quot;0000&quot;) ; TestCase.assertNotNull(member); &#125; @Test public void list() throws SQLException &#123; IMemberService memberService = ObjectFactory.getServiceInstance(&quot;member.service&quot;) ; List&lt;Member&gt; all = memberService.list() ; TestCase.assertTrue(all.size()&gt;0); &#125; @Test public void split() throws SQLException &#123; IMemberService memberService = ObjectFactory.getServiceInstance(&quot;member.service&quot;) ; Map&lt;String,Object&gt; map = memberService.split(1,1,&quot;&quot;,&quot;&quot;) ; //Map&lt;String,Object&gt; map = memberService.split(1,1,&quot;mid&quot;,&quot;0&quot;) ; //两种分别测试一下 TestCase.assertTrue(map.get(&quot;allMembers&quot;) != null &amp;&amp; map.get(&quot;allRecorders&quot;) != null); &#125;&#125; 常见报错java.lang.NullPointException 常见于dbc，factory，proxy操作中，如果遇到空指向，先检查是否这部分出错； 一个奇怪（葩）的问题，如果add、edit、remove方法通过，查询方法报错，检查ServiceProxy类的事务控制逻辑是否有误 SQL语句拼接错误 此处要小心空格的问题，以及占位符（？）的值的设置 junit.framework.AssertionFailedError断言错误，TestCase断言错误，此时一般要查询Service实现类中返回的数据 数据库连接失败检查数据库服务是否开启，url，driver，user，password是否配置错误 DAO实现思路（debug路线）工厂类(代理对象(ServiceImpl类实例化对象))获取IService类实例化对象→调用操作方法(ServiceImpl下的方法)→实例化IDAO对象(通过工厂类由DAOImpl对象向上转型获得)→调用DAO层方法→调用AbstractDAO类方法获取数据库连接→数据层操作","tags":[{"name":"DAO","slug":"DAO","permalink":"http://yoursite.com/tags/DAO/"}]},{"title":"JVM常用参数","date":"2019-05-01T07:39:32.000Z","path":"2019/05/01/computer/JVM常用参数/","text":"##编译器-client：C1，启动速度快，占用内存小，执行效率慢于C2模式，默认状态下不进行动态编译，适合于单机桌面版程序运行 -server：C2，默认的编译器，启动速度慢，占用内存多，执行效率高，适合于服务器端使用 ##内存配置-Xms:初始堆大小 -Xmx：最大堆大小 -Xss：设置每个线程的堆栈大小。JDK 5 以后每个线程栈大小为1M，以前每个线程堆栈大小为256k -XX:NewSize=n:设置年轻代大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如：3表示年轻代和年老代比值为3：1，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden： 3 Survivor：2，一个Survivor区占整个年轻代的1/5 -XX:MaxPermSize=n:设置永久代大小 ##收集器设置 -XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器，仅对年轻代有效，此配置下，年轻代使用并行收集，而年老代仍旧使用串行收集。 -XX:+UseParalledlOldGC:设置并行年老代收集器，JDK 6 支持对老年代并行收集 -XX:+UseConcMarkSweepGC:设置并发收集器 ##垃圾回收统计信息-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename ##并行收集器配置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数 -XX:MaxGCPauseMillis=n:设置并行收集最大的暂停时间（如果到时间没有回收完，会停止回收） -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n) -XX:+CMSIncrementalMode:设置为增量模式 -XX:+UseAdaptiveSizePolicy:设置此选项以后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Hello World","date":"2018-11-20T11:34:14.000Z","path":"2018/11/20/computer/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hello","slug":"Hello","permalink":"http://yoursite.com/tags/Hello/"}]}]